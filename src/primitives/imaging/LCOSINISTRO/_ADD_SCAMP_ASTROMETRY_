# -*-cperl-*-

=head1 NAME

_ADD_SCAMP_ASTROMETRY_ -- Performs automated astrometric corrections using SCAMP.

=head1 DESCRIPTION

This primitive automatically corrects astrometry for a given
observation.  It does so by detecting objects in the observation
using SExtractor and then using SCAMP to determine the correlation
between the source catalogue and a downloaded catalog (normally UCAC-4),
and calculates an astrometric solution.

=head1 ARGUMENTS

=over 4

=item GROUP = LOGICAL (Given)

If set to true (1), then the current Group object will have its
astrometry corrected. Otherwise, this primitive operates on the
current Frame object. [1]

=item MAXCOEFF = INTEGER (Given)

The maximum coefficient model to perform. The allowed values are 4, 6,
7, 8, and 9. See SUN/5 for a description of the models. If, for
example, ASTROM can only calculate a 6-coefficient model and a
9-coefficient model was requested, then the 6-coefficient model will
be used. [9]

=item OUTPUT_CATALOGUE = STRING (Given)

If set, then an output catalogue of detected objects will be written
to this value.

=item STATISTICS = LOGICAL (Given)

If set to true (1), then image statistics will be calculated for the
resulting frame. For a full list of statistics, see the
C<_CALCULATE_IMAGE_STATISTICS_> primitive. [0]

=head1 NOTES

=over 4

=item *

This primitive is suitable for optical imaging instruments.

=item *

Processing only occurs when the steering header ADD_ASTROMETRY is
true.

=item *

Processing occurs on the current Group object.

=item *

Astrometric correction will probably fail if fewer than five objects
are detected in the frame. Should this occur, the original WCS will be
retained.

=item *

Should an astrometric solution be found, the WCS in the current Group
will be overwritten with the solution.

=back

=head1 REQUIRED PERL MODULES

Astro::FITS::Header.
IPC::Cmd.
Astro::Catalog.

=head1 AUTHORS

Tim Lister (LCOGT) <tlister@lcogt.net>

=head1 COPYRIGHT

Copyright (C) 2014-2015 Las Cumbres Observatory Global Telescope Inc.
All Rights Reserved.

=cut

use IPC::Cmd qw/ can_run run /;

# Set to use IPC::Run if available (better buffer handling?)
if ( defined( IPC::Cmd->can_use_ipc_run ) ) {
  $IPC::Cmd::USE_IPC_RUN = 1;
}

use constant R2DEG => 57.29577951;

# Only do this if we're told.
if( $Frm->uhdr( "ADD_ASTROMETRY" ) ) {

  # Deal with parameters.
  my $in;
  my $group;
  my $Obj;
  if( defined( $_ADD_SCAMP_ASTROMETRY_{GROUP} ) &&
      $_ADD_SCAMP_ASTROMETRY_{GROUP} == 0 ) {
    ( $in, my $out ) = $Frm->inout( "_cat" );
    $group = 0;
    $Obj = $Frm;
  } else {
    $in = $Grp->file;
    $group = 1;
    $Obj = $Grp;
  }
  my $statistics = $_ADD_SCAMP_ASTROMETRY_{STATISTICS};
  if( ! defined( $statistics ) ) {
    $statistics = 0;
  }
  my $maxcoeff = $_ADD_SCAMP_ASTROMETRY_{MAXCOEFF};
  if( ! defined( $maxcoeff ) ||
      ! ( $maxcoeff == 4 ||
          $maxcoeff == 6 ||
          $maxcoeff == 8 ||
          $maxcoeff == 9 ) ) {
    $maxcoeff = 9;
  }
  _GET_PLATE_SCALE_
  my $platescale = $_GET_PLATE_SCALE_{PLATESCALE};
  print "Original platescale=$platescale\n";

  orac_print "Adding accurate astrometry to $in (maxcoeff=$maxcoeff).\n";
  $Obj->uhdr( "ASTROMETRY_ADDED", 0 );

  # We need the scamp binary. Display a warning
  # to the user if it cannot be run.
  my $isok = can_run('scamp');
  if( ! defined ($isok) ) {
    orac_warn "Could not execute the scamp binary: $@\n";
    orac_warn "Continuing with data reduction.\n";
  } else {
#    print "Retrieving original WCS\n";
    my $orig_wcs = $Obj->read_wcs( );

    # Create scamp-format FITS LDAC catalogue
    _CREATE_SCAMP_CATALOGUE_ GROUP=$_ADD_SCAMP_ASTROMETRY_{GROUP}

    # Determine the output catalogue filename.
    my $output_catalogue = $in;
    if ( $Frm->uhdr( "QUICK_LOOK" ) == 1 ) {
      $output_catalogue =~ s/02_bp_ff/09_cat.ldac/;
    } else {
      $output_catalogue =~ s/02_bp_ff/89_cat.ldac/;
    }

    # See if there are any non-saturated stars in the catalog, otherwise there
    # is no point even running SCAMP.
    
    my $ldac_catalogue = new  Astro::Catalog( Format => 'LCOGTFITSTable',
                                              File => $output_catalogue,
                                              ReadOpt => { Quality => 0 },
                                            );

#    print "Number of non-saturated stars=" . $ldac_catalogue->sizeof() . "\n";
    # Retrieve the scamp configuration file.
    my $scamp_cfg = $Cal->find_file( "scamp_fs.config" );

    # Retrieve the scamp catalogue list.
    my $scamp_cats = $Cal->scamp_catalogue;
    my $timeout = 180;

    my @full_buf;
    my @stdout_buf;
    my @stderr_buf;
    my $astromver;
    my( $success, $error_msg, $full_buf_ref, $stdout_buf_ref, $stderr_buf_ref );

# If we have some non-saturated stars, run SCAMP on the catalog.
    if ( $ldac_catalogue->sizeof() > 0 ) {

      my $scamp_cmd = "$isok $output_catalogue -c $scamp_cfg";
#      print "SCAMP cmd=$scamp_cmd\n";
 
# Execute scamp, capturing status and buffers with verbosity turned off and
# setting a timeout for running of 120 seconds
      ( $success, $error_msg, $full_buf_ref, $stdout_buf_ref, $stderr_buf_ref ) =
              run( command => $scamp_cmd, verbose => 0, timeout => $timeout );

#      print "Success=$success\n";
    
# Dereference array reference.
      @full_buf = @$full_buf_ref;
      print "full_buf=\n@full_buf\n\n-------------------------------\n";
    } else {
# Run SCAMP again to determine version number    
      my $scamp_cmd = "$isok --version";
      ( $success, $error_msg, $full_buf_ref, $stdout_buf_ref, $stderr_buf_ref ) =
              run( command => $scamp_cmd, verbose => 0, timeout => $timeout );
      $error_msg = "No non-saturated stars.\n";
      $success = -1;
# Dereference array reference.
      @full_buf = @$full_buf_ref;
# Determine version number
      my @fields = split(/\s+/,  $full_buf[0]);
      $astromver = $fields[0] . "-V" . $fields[2];

    }
      
    my $raoffset = 0.0;
    my $decoffset = 0.0;
    my $fitrms;
    my $fitstatus = '3';
    my %results;
    my $new_wcs;
    my $header;
    my $catsize = 0;
    my $badfit;
    if( $success != 1 ) {

      orac_warn "Error adding accurate astrometry to $in: $error_msg";
      
      $results{'plate'} = $platescale;
      $results{'xrms'} = 99.0;
      $results{'yrms'} = 99.0;
      $results{'nstars'} = 0;
      $results{'nterms'} = 0;
      $raoffset = 0.0;
      $decoffset = 0.0;

      if( $error_msg =~ /^IPC::Cmd::TimeOut/ ) {
# Failed due to timeout on catalog query
        my @cats = split ",", $scamp_cats;
        push( @cats, shift( @cats ) );
        $scamp_cats = join ",", @cats;

        orac_warn "Automated astrometry took longer than $timeout seconds. Assuming something wrong with query catalogue. Setting order to $scamp_cats.\n";

        $Cal->scamp_catalogueindex->add( 2, { SCAMP_CATALOGUE => $scamp_cats,
                                               ORACTIME => $Frm->hdr( "ORACTIME" ) } );

      } else {
# Failed for a different reason      
          my @errors = grep { /\*Error\*:/ } @full_buf;
          my $reason = 'Unknown';
          if ( scalar @errors == 1 ) {
              $reason = $errors[0];
          }
          orac_warn "Automated astrometry failed with reason: $reason\n";
      }

    } else {
      $badfit = 0;

      # Read in scamp output file
      my $wcs_file = $output_catalogue;
      $wcs_file =~ s/\.ldac/.head/;

      my @hdr_array = do {
        open my $fits_fh, "<", $wcs_file or orac_warn "Could not open $wcs_file: $!";
        <$fits_fh>;
      };


      $header = new Astro::FITS::Header( Cards => \@hdr_array );
      my $dateobs = $Frm->hdr( "DATE-OBS");
      my $item = new Astro::FITS::Header::Item( Keyword => 'DATE-OBS',
                                         Value => $dateobs,
                                         Comment => '[UTC] Start date and time of the observation',,
                                         Type => 'string'
                                       );
      $header->append( $item );
      $new_wcs = $header->get_wcs;

# Calculate RA/Dec offsets in arcsecs
	$raoffset = ($Frm->uhdr( "ORAC_RA_BASE" ) - $header->value("CRVAL1"))*3600.0;
	$decoffset = ($Frm->uhdr( "ORAC_DEC_BASE" ) - $header->value("CRVAL2"))*3600.0;
	my $ratrim = $Frm->uhdr( "ORAC_X_LOWER_BOUND" ) * $platescale;
	my $dectrim = $Frm->uhdr( "ORAC_Y_LOWER_BOUND" ) * $platescale;
	$raoffset = $raoffset - $ratrim;
	$decoffset = $decoffset - $dectrim;
        $results{'xrms'} = sprintf "%.5f", $header->value("ASTRRMS1") * 3600.0;
        $results{'yrms'} = sprintf "%.5f", $header->value("ASTRRMS2") * 3600.0;

# Read from output buffer of run to extract stuff we need
        my @num_detects = grep { /detections\ loaded$/ } @full_buf;
        my @fields;
        if ( scalar @num_detects > 0) {
          @fields = split(/\s+/,  $num_detects[0]);
          $catsize = $fields[2];
        }
        print "#stars in input=$catsize\n";

# Extract fitted pixel scale
        my @field_info = grep { /A1  P1/ } @full_buf;
        if ( scalar @field_info == 2) {
          my $start = rindex($field_info[1], 'Group  1:');
          print "Start=$start\n";
          my $new_field_info = $field_info[1];
          if ( $start != -1 ) {
            $new_field_info = substr($new_field_info, $start);
          } else {
            print "Substring not found\n";
          }  
          @fields = split(/\s+/,  $new_field_info);
          my $num_fields = scalar @fields;
          print "field_info=\n-------------------------------\n$new_field_info\n-------------------------------\n";
          print "#fields=$num_fields\n";
          if ( $num_fields == 24 ) { 
            print "#fields=$num_fields $fields[2] $fields[19] $fields[20]\n";
            $results{'plate'} = $fields[19];
            $results{'plate'} =~ s/"//;
          } else {
            print join(", ", @fields);
            $results{'plate'} = $platescale;
            print "Unexpected number of fields in field_info\n";
            orac_err "Unexpected number of fields in field_info\n";
            $badfit = 1;
          }
          print "Fitted platescale=$results{'plate'}\n";
        } else {
          print "Unexpected output\n";
          $badfit = 1;
        } 
# Extract fit details
        my @fit_info = grep { /Astrometric stats \(external\)/ } @full_buf;
        print "Num matches=" . scalar @fit_info . "\n";
        if ( scalar @fit_info == 1) {
          my $start = index($fit_info[0], '-----');
          my $end = index($fit_info[0], '-----', $start + 1);
          print "Start, End=$start $end\n";
          my $new_fit_info = $fit_info[0];
          if ( $start != -1 and $end != -1 ) {
            $new_fit_info = substr($new_fit_info, $start, $end-$start);
          } else {
            print "Substring not found\n";
          }  
        
          @fields = split(/\s+/,  $new_fit_info);
          my $num_fields = scalar @fields;
          print "fit_info=\n-------------------------------\n$new_fit_info\n-------------------------------\n";
          print "#fields=$num_fields\n";
          if ( $num_fields == 28 ) { 
              print "#fields=$num_fields $fields[24] $fields[25] $fields[27]\n";
              $results{'nstars'} = $fields[27];
          } else {
              $results{'nstars'} = 0;
              print "Unexpected number of fields in fit_info\n";
              print join(", ", @fields);
              orac_err "Unexpected number of fields in fit_info\n";
              $badfit = 1;
          }
          print "#stars fitted  =$results{'nstars'}\n";
        } else {
          print "Unexpected output\n";
          print "fit_info=\n-------------------------------\n@fit_info\n-------------------------------\n";
          $badfit = 1;
        } 

# Determine version number
        @fields = split(/\s+/,  $full_buf[0]);
        $astromver = $fields[1] . "-V" . $fields[2];

      	$fitstatus = '0';
      }
# Check fit quality
      my $rms_thresh = 2.0;
      if ( $results{'xrms'} > $rms_thresh*$platescale or 
        $results{'yrms'} > $rms_thresh*$platescale or $badfit == 1 ) {
      	orac_print "Bad astrometric fit detected.\n";
      	print "DBG: Bad astrometric fit detected.\n";
	print "DBG: nstars=$results{'nstars'},\nDBG: plates=$results{'plate'},";
	print "\nDBG: pscale=$platescale,\nDBG:   xrms=$results{'xrms'},\nDBG:   yrms=$results{'yrms'},";
	print "\nDBG: thresh=" . $rms_thresh * $platescale . "\n";
# Put original WCS back
	$Obj->write_wcs( $orig_wcs );
	orac_print  "WCS reset in " . $Obj->file . ".\n";

	$results{'plate'} = $platescale;
	$results{'xrms'} = -99.0;
	$results{'yrms'} = -99.0;
	$results{'nstars'} = 0;
	$results{'nterms'} = 0;
	$raoffset = 0.0;
	$decoffset = 0.0;
      	$fitstatus = '4';
      } else {
# Put new WCS back
	$Obj->write_wcs( $new_wcs );
	orac_print  "WCS commit in " . $Obj->file . ".\n";
	orac_print "Accurate astrometry added to $in.\n";
	orac_print "Catalogue written to $output_catalogue.\n";
	$Obj->uhdr( "ASTROMETRY_ADDED", 1 );

	orac_print "Changing system to ICRS\n";
	$Mon{ "ndfpack_mon" }->obeyw( "wcsattrib", "ndf=$in mode=set name=System newval=ICRS");

	# Display, if requested.
	$Display->display_data( $Obj ) if ( defined( $Display ) );

      }
    
    $fitrms = $results{'xrms'} . "/" . $results{'yrms'};
    my $rawcat = $output_catalogue;

    my @cats = split(',', $scamp_cats);
    my $cattype = $cats[0];
    my $refcat = '<Vizier/aserver.cgi?' . lc($cattype) . ">";

# Old version string method from header (gives a revision date but relies on
# the output header being created which it won't in the case of problems.
#    my $astromver =  $header->itembyname("HISTORY");
#    $astromver =~ s/HISTORY\s+Astrometric\ solution\ by\ //;
#    $astromver =~ s/\s+$//;
#    $astromver =~ s/ version /-V/;
#    $astromver =~ s/\s+/_/;
#    print $astromver . "XXX\n";

    # File the whole shebang with the calibration system.
    my %calhash = ( %{$Frm->hdr},
    		    SECPIX => $results{'plate'},
    		    XRMS => $results{'xrms'},
    		    YRMS => $results{'yrms'},
		    NSTARS => $results{'nstars'},
		    OFFSETRA => $raoffset,
		    OFFSETDEC => $decoffset,
    		  );
    $Cal->astromqcindex->add( $Frm->file, \%calhash );
# Update FITS header items
    if ( $fitstatus == '0' ) {
      _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=SECPIX VALUE=$results{'plate'} COMMENT=[arcsec/pixel]|Fitted|pixel|scale|on|sky
    } else {
      _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=SECPIX VALUE=$results{'plate'} COMMENT=[arcsec/pixel]|Nominal|pixel|scale|on|sky
    }
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCSSOLVR STRING=TRUE VALUE=$astromver COMMENT=WCS|solver
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCSRFCAT VALUE=$refcat COMMENT=Fname|of|astrometric|catalog
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCSIMCAT VALUE=$rawcat COMMENT=Fname|of|detection|catalog
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCSNREF  VALUE=$catsize COMMENT=Stars|in|image|available|to|define|WCS
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCSMATCH VALUE=$results{'nstars'} COMMENT=Stars|in|image|matched|against|ref|catalog
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCCATTYP VALUE=$cattype COMMENT=Reference|catalog|used
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCNTERMS VALUE=6 COMMENT=No.|of|terms|used|in|WCS|fit
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCSRDRES VALUE=$fitrms COMMENT=[arcsec]|WCS|fitting|residuals|(x/y)
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCSDELRA VALUE=$raoffset COMMENT=[arcsec]|Shift|of|fitted|WCS|w.r.t.|nominal
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCSDELDE VALUE=$decoffset COMMENT=[arcsec]|Shift|of|fitted|WCS|w.r.t.|nominal
    _SET_FILE_FITS_ITEM_ FILE=$Obj->file KEY=WCSERR VALUE=$fitstatus COMMENT=Error|status|of|WCS|fit.|0|for|no|error

    _DELETE_FILE_FITS_ITEM_ FILE=$Obj->file KEY=L1FILTER
#    orac_print "Removing catalogue $output_catalogue.\n";
#    unlink $output_catalogue;
    # Remove scamp output file
    my $wcs_file = $output_catalogue;
    $wcs_file =~ s/\.ldac/.head/;
#    orac_print "Removing header file $wcs_file.\n";
#    unlink $wcs_file;
    
  }
  # Tidy up output.
  orac_print "\n";

}
